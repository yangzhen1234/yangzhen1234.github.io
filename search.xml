<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>创建对象和原型链</title>
      <link href="2020/12/25/chuang-jian-dui-xiang-he-yuan-xing-lian/"/>
      <url>2020/12/25/chuang-jian-dui-xiang-he-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><ul><li><p>封装</p></li><li><p>继承</p></li><li><p>多态</p></li></ul><h3 id="原型链的知识"><a href="#原型链的知识" class="headerlink" title="原型链的知识"></a>原型链的知识</h3><p>原型链是面向对象的基础，是非常重要的部分。有以下几种知识：</p><ul><li><p>创建对象有几种方法</p></li><li><p>原型、构造函数、实例、原型链</p></li><li><p><code>instanceof</code>的原理</p></li><li><p>new 运算符</p></li></ul><h2 id="创建对象有几种方法"><a href="#创建对象有几种方法" class="headerlink" title="创建对象有几种方法"></a>创建对象有几种方法</h2><h3 id="方式一：字面量"><a href="#方式一：字面量" class="headerlink" title="方式一：字面量"></a>方式一：字面量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj11 = &#123;<span class="attr">name</span>: <span class="string">&#x27;qianguyihao&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj12 = <span class="keyword">new</span> <span class="built_in">Object</span>(name: <span class="string">&#x27;qianguyihao&#x27;</span>); <span class="comment">//内置对象（内置的构造函数）</span></span><br></pre></td></tr></table></figure><p>上面的两种写法，效果是一样的。因为，第一种写法，<code>obj11</code>会指向<code>Object</code>。</p><ul><li><p>第一种写法是：字面量的方式。</p></li><li><p>第二种写法是：内置的构造函数</p></li></ul><h3 id="方式二：通过构造函数"><a href="#方式二：通过构造函数" class="headerlink" title="方式二：通过构造函数"></a>方式二：通过构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> M(<span class="string">&#x27;smyhvae&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="方法三：Object-create"><a href="#方法三：Object-create" class="headerlink" title="方法三：Object.create"></a>方法三：Object.create</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;smyhvae&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(p);  <span class="comment">//此方法创建的对象，是用原型链连接的</span></span><br></pre></td></tr></table></figure><p>第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的原型（name是p原型里的属性），构造函数是<code>Objecet</code> 。</p><p><img src="http://img.smyhvae.com/20180306_1633.png"></p><h2 id="原型、构造函数、实例，以及原型链"><a href="#原型、构造函数、实例，以及原型链" class="headerlink" title="原型、构造函数、实例，以及原型链"></a>原型、构造函数、实例，以及原型链</h2><p><img src="http://img.smyhvae.com/20180306_1540.png"></p><p>PS：任何一个函数，如果在前面加了new，那就是构造函数。</p><h3 id="原型、构造函数、实例三者之间的关系"><a href="#原型、构造函数、实例三者之间的关系" class="headerlink" title="原型、构造函数、实例三者之间的关系"></a>原型、构造函数、实例三者之间的关系</h3><p><img src="http://img.smyhvae.com/20180306_2107.png"></p><ul><li><p>1、构造函数通过 new 生成实例</p></li><li><p>2、构造函数也是函数，构造函数的<code>prototype</code>指向原型。（所有的函数有<code>prototype</code>属性，但实例没有 <code>prototype</code>属性）</p></li><li><p>3、原型对象中有 constructor，指向该原型的构造函数。</p></li></ul><p>上面的三行，代码演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Foo &#x3D; function (name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new Foo(&#39;smyhvae&#39;);</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>Foo.prototype.constructor === Foo</code>的结果是<code>true</code>：</p><p><img src="http://img.smyhvae.com/20180306_2120.png"></p><ul><li>4、实例的<code>__proto__</code>指向原型。也就是说，<code>foo.__proto__ === Foo.prototype</code>。</li></ul><p>声明：所有的<strong>引用类型</strong>（数组、对象、函数）都有<code>__proto__</code>这个属性。</p><p><code>Foo.__proto__ === Function.prototype</code>的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>原型链的基本原理</strong>：任何一个<strong>实例</strong>，通过原型链，找到它上面的<strong>原型</strong>，该原型对象中的方法和属性，可以被所有的原型实例共享。</p><p>Object是原型链的顶端。</p><p>原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;给Foo的原型添加 say 函数</span><br><span class="line">Foo.prototype.say &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原型链的关键</strong>：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。</p><h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a><code>instanceof</code>的原理</h3><p><img src="http://img.smyhvae.com/20180306_2209.png"></p><p><code>instanceof</code>的<strong>作用</strong>：用于判断<strong>实例</strong>属于哪个<strong>构造函数</strong>。</p><p><code>instanceof</code>的<strong>原理</strong>：判断实例对象的<code>__proto__</code>属性，和构造函数的<code>prototype</code>属性，是否为同一个引用（是否指向同一个地址）。</p><p><strong>注意1</strong>：虽然说，实例是由构造函数 new 出来的，但是实例的<code>__proto__</code>属性引用的是构造函数的<code>prototype</code>。也就是说，实例的<code>__proto__</code>属性与构造函数本身无关。</p><p><strong>注意2</strong>：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找<code>__proto__</code>属性。这条链上如果能找到， instanceof 的返回结果也是 true。</p><p>比如说：</p><ul><li><p><code>foo instance of Foo</code>的结果为true，因为<code>foo.__proto__ === Foo.prototype</code>为true。</p></li><li><p><strong><code>foo instance of Objecet</code>的结果也为true</strong>，因为<code>Foo.prototype.__proto__ === Object.prototype</code>为true。</p></li></ul><p>但我们不能轻易的说：<code>foo 一定是 由Object创建的实例</code>。这句话是错误的。我们来看下一个问题就明白了。</p><h3 id="分析一个问题"><a href="#分析一个问题" class="headerlink" title="分析一个问题"></a>分析一个问题</h3><p><strong>问题：</strong>已知A继承了B，B继承了C。怎么判断 a 是由A<strong>直接生成</strong>的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？</p><p>分析：这就要用到原型的<code>constructor</code>属性了。</p><ul><li><code>foo.__proto__.constructor === Foo</code>的结果为true，但是 <code>foo.__proto__.constructor === Object</code>的结果为false。</li></ul><p>所以，用 consturctor判断就比用 instanceof判断，更为严谨。</p><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><p>当new Foo()时发生了什么：</p><p>（1）创建一个<strong>新的空对象实例</strong>。</p><p>（2）将此空对象的隐式原型指向其构造函数的显示原型。</p><p>（3）执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。</p><p>（4）如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。</p><p>参考《JS高程》6.2.2</p><h2 id="类继承和原型继承的区别"><a href="#类继承和原型继承的区别" class="headerlink" title="类继承和原型继承的区别"></a>类继承和原型继承的区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 对象和原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做项目过程中的总结</title>
      <link href="2020/12/25/zuo-xiang-mu-guo-cheng-zhong-de-zong-jie/"/>
      <url>2020/12/25/zuo-xiang-mu-guo-cheng-zhong-de-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>1.开始</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试知识点</title>
      <link href="2020/12/25/qian-duan-mian-shi-zong-jie/"/>
      <url>2020/12/25/qian-duan-mian-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="面试前准备"><a href="#面试前准备" class="headerlink" title="面试前准备"></a>面试前准备</h2><h3 id="面试分为三部分"><a href="#面试分为三部分" class="headerlink" title="面试分为三部分"></a>面试分为三部分</h3><ul><li><p>技术面试：问技术问题。</p></li><li><p>负责人面试：考察综合能力。比如：项目把控能力、项目深度、项目架构、业务等。</p></li><li><p>hr 面试：侧重于性格、沟通、潜力等。</p></li></ul><p>每轮面试在一小时左右。</p><h3 id="每轮面试的知识点"><a href="#每轮面试的知识点" class="headerlink" title="每轮面试的知识点"></a>每轮面试的知识点</h3><p>一面：</p><blockquote><p>主要考察基础知识。</p></blockquote><ul><li><p>页面布局</p></li><li><p>CSS盒模型、DOM事件</p></li><li><p>HTTP 协议、原型链</p></li><li><p>面向对象、通信</p></li><li><p>前端安全、算法</p></li></ul><p>二面：</p><ul><li><p>渲染机制</p></li><li><p>JS 运行机制</p></li><li><p>页面性能</p></li><li><p>错误监控</p></li></ul><p>三面：</p><blockquote><p>不再关注技术层面。</p></blockquote><ul><li><p>业务能力</p></li><li><p>团队协作能力</p></li><li><p>带人能力</p></li></ul><p>终面：</p><ul><li><p>职业竞争力</p></li><li><p>职业规划</p></li></ul><p>面试成功需要：技术过关、面试技巧等。</p><h3 id="校招和社招各自看中的层面"><a href="#校招和社招各自看中的层面" class="headerlink" title="校招和社招各自看中的层面"></a>校招和社招各自看中的层面</h3><p>校招：</p><ul><li><p>知识：40%</p></li><li><p>能力：59%</p></li><li><p>经验：1%</p></li></ul><p>社招：</p><ul><li><p>知识：30%。比如协议、业务的认知程度。</p></li><li><p>能力：50%。比如架构、业务的抽象能力、项目的把控能力。</p></li><li><p>经验：20%。项目的体现。</p></li></ul><p>以上仅供参考。</p><h3 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h3><p>面试准备包括以下四个部分：</p><ul><li><p>职位描述（JD）的分析</p></li><li><p>业务分析</p></li><li><p>技术栈准备</p></li><li><p>自我介绍</p></li></ul><p>每个公司又有一套成熟的技术栈。比如在构建工具上，百度用 fis3、美团用 Gulp。</p><p>你要面哪个公司，要先看看对方要求的技术栈。</p><p>上面四个部分，我们接下来详细介绍。</p><h4 id="职位描述（JD）的分析"><a href="#职位描述（JD）的分析" class="headerlink" title="职位描述（JD）的分析"></a>职位描述（JD）的分析</h4><p>介绍</p><p>概念：</p><ul><li><p>职位描述：注重的是工作职责。</p></li><li><p>任职要求：要求的是工作能力。通常描述得很细致。</p></li></ul><p>PS：前端的知识庞大，不可能所有的内容都准备好，但是要向“任职要求”靠拢。</p><p>分析职位描述（JD）的目的是：</p><ul><li><p>快速识别出这个岗位是否是自己喜欢的、想要的。</p></li><li><p>目前的技能是否能胜任岗位的要求。短期内的准备能否胜任。</p></li></ul><p><strong>举例1：京东 web 前端的职位描述</strong></p><p>如下：</p><p><img src="http://img.smyhvae.com/20180304_2132.png"></p><p><strong>职位描述：</strong></p><p>（1）面试时，会同时考虑到 <code>PC 端和移动端</code>两个部分。</p><p>（2）<code>App H5开发</code>指的是两层意思：</p><ul><li><p>Hybrid 技术栈。</p></li><li><p>纯 H5 开发。和 native 开发没有关系，比如活动、专题。</p></li></ul><p>（3）<code>调试数据接口</code>：要学习一下怎么模拟数据。</p><p>（4）<code>前端组件库的建立</code>：要求较高但非常重要。体现在：</p><ul><li><p>基本功要扎实，原生 js、css的理解要到位。</p></li><li><p>之前有没有前端组件库相关的项目经验</p></li><li><p>是否通读过其他的 UI 组件库。</p></li></ul><p>（5）<code>优化与重构</code>：难度比第四条更大。</p><p>PS：前三条是基本知识，第四条、第五条属于进阶。</p><p><strong>任职要求：</strong></p><p>（1）<code>3年以上工作经验</code>：不要太较真工作年限。<code>精通 H5 特性</code>：说明公司很看重移动端。了解H5<code>最新规范</code>：贵公司希望我对新技术是有追求的，比如<code>ES6</code>等。</p><p>（2）要求我们对<code>面向对象</code>部分有足够的了解。组件化的编程也离不开面向对象。</p><p>（3）体现了几点：</p><ul><li><p><code>熟悉 Web 标准</code>：熟悉最新的标准即可。</p></li><li><p><code>表现与数据分离</code>：MVC框架。</p></li><li><p><code>语义化</code>：这个词千万不要忽视。不是什么都用 div。</p></li><li><p><code>实际经验</code>：利用框架开发的过程中，遇到过哪些问题？没有实际经验的话，也要提前准备几个问题。</p></li></ul><p>（4）以下几点：</p><ul><li><code>前端架构分析与设计...</code>：说明此岗位并不面对初级岗位。因为工作一至两年的人，大部分都是<strong>做业务开发</strong>，缺少<strong>系统的架构能力</strong>。</li></ul><p>我们要准备一个项目的架构（比如公司现有的项目）重新梳理，包含：目录结构的设计、复用性设计、模块化设计、自动化测试、上线流是什么。</p><ul><li><p><code>易读、易维护的代码</code>：面试过程中一定会让你写代码，来体现。要求；每个函数的功能要单一、能抽象尽量抽象。符合这两个原则，基本就满足了“易读、易维护”。</p></li><li><p><code>高质量、高效率的代码</code>，短时间内不好准备。</p></li></ul><p>（5）<code>用户可用性、用户体验、用户研究</code>：考察的不是技术，而是候选人对于产品体验的理解。不仅仅只是完成功能而已。</p><p>（6）<code>强烈兴趣</code>等，是公司企业文化的一种要求。多去GitHub上看看别人的项目里用的什么新技术、多看博客。短时间内无法准备。</p><p>（7）了解<code>Sass</code>和<code>Less</code>：这是基本技能。</p><p>（8）<strong>熟悉</strong><code>web构建工具</code>：新手推荐学习 Glup，而不是 grunt。当然，你要知道 <strong>Glup 和 grunt 的区别</strong>。</p><p>PS：了解、熟悉、精通，是有区别的。</p><p>（9）暂时可以忽略。如果 职位描述里没有要求<code>Node.js</code>，而你只会一点点 <code>Node.js</code>，那不建议你面试的时候把<code>Node.js</code>体现出来。否则是给自己挖坑。</p><p><strong>举例2：艺龙的 web 前端的职位描述</strong></p><p>如下：</p><p><img src="http://img.smyhvae.com/20180304_2226.png"></p><p>此方位</p><p><strong>职位描述：</strong></p><p>（1）<code>系统化设计</code>：说的比较笼统。其实指的就是模块化设计、前后端分离（<strong>数据渲染</strong>交给前端）。</p><p>（2）几点：</p><ul><li><p>前半句：并没有说 H5 是放在移动端做，可能同时包含 PC 和移动端。</p></li><li><p>后半句：可以看出公司对 H5 动画的要求很高。动画有三种方式：用DOM写、SVG 的path做动画、canvas。canvas 又分 2D 和 3D。我们要看岗位描述里怎么要求的。既然提到CSS3，那么CSS3里面的animation、tansition也要了解。</p></li></ul><p>（3）微信项目，要准备：</p><ul><li><p>小程序：比如看贵公司有小程序吗？我们自己要准备简单的开发和文档、组件化的内容。</p></li><li><p>微信支付。</p></li><li><p>对微信开发中的哪些坑，要了解</p></li></ul><p>（4）和京东的第四条很像，既要会框架，也要会组件化设计。但京东的侧重从零开始，而艺龙侧重于：有的就维护，没有的就开发。</p><p><strong>岗位要求：</strong></p><p>（1）<code>各种</code>web前端技术：用词不严谨。</p><p>（2）几点：</p><ul><li><p><code>Web</code>标准：JS的最新标准是ES6。</p></li><li><p><code>可用性、可访问性</code>：侧重于网站的性能。 前端要做性能监控、错误监控。JS异常分为两种：<strong>运行异常</strong>、<strong>资源加载错误</strong>。一般人只能说出第一种异常。</p></li></ul><p>（3）<code>工程化</code>：<strong>工程化</strong>已经是前端的必备技能。<code>webpack</code>是必须的工具，<code>grunt</code>已经过时了，如果公司提到，还是要了解。<code>Gulp</code>用的很多。</p><p>（4）写得比较虚，面试时基本很难考察。面试时，如果写代码，要注意代码风格，该用 class、id、标签时，要注意区分。</p><p>（5）要准备一下 Node.js。<code>至少熟悉一门</code>：可能要求全栈开发。</p><p>（6）<code>逻辑性强</code>：能说出123。</p><p><strong>业务分析</strong></p><blockquote><p>业务分析</p></blockquote><p>CSS3 动画是重点准备的内容。</p><p>jQuery 要准备事件委托、选择器等。</p><p>ES6语法：import、export等。</p><p>比如<a href="http://jr.jx.com/">http://jr.jx.com/</a>这个网站：</p><p><img src="http://img.smyhvae.com/20180304_2302.png"></p><p>通过简单分析源码，我们初步得知网站的以下几点：</p><ul><li><p>jQuery</p></li><li><p>vue 框架</p></li><li><p>ES6</p></li><li><p>webpack 打包工具</p></li></ul><p><strong>技术栈准备</strong></p><p><img src="http://img.smyhvae.com/20180310_1040.png"></p><p>上图中，左侧是前端技术核心，右侧是前端工程化。</p><p>左侧：</p><ul><li><p>jQuery：要注意看源码。看源码时，要看这几个：核心架构、事件委托是什么、插件机制、兼容性。</p></li><li><p>三大框架：都是mvvm框架，准备一至两个即可，或者精心准备一个。面试时会问得很细。比如阿里会经常问Vue的源码。建议找网上的源码分析的文章。</p></li><li><p>Node.js：如果没有相关项目经历，就尽量不要提。</p></li></ul><p>右侧：</p><ul><li><p>npm：npm的常见命令、npm scripts 怎么用的。</p></li><li><p>webpack：有个中文网站，讲的内容比较全。</p></li></ul><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>面试问的问题，很大层次上，取决你的简历和自我介绍。</p><h4 id="简历"><a href="#简历" class="headerlink" title="简历"></a><strong>简历</strong></h4><p>简历中最重要的四个信息：</p><ul><li><p>基本信息：姓名、年龄、手机、邮箱、籍贯。</p></li><li><p>学历：从大到小写。硕士 -&gt; 本科。</p></li><li><p>工作经历：时间、公司、岗位、职责、技术栈、<strong>业绩</strong>。业绩是大多数人所忽略的。</p></li><li><p>开源项目、Github、说明。</p></li></ul><p>自我评价可以不写。</p><p>项目的业绩上，要包括：<strong>技术收益</strong>和<strong>业绩收益</strong>。</p><h4 id="自我陈述"><a href="#自我陈述" class="headerlink" title="自我陈述"></a><strong>自我陈述</strong></h4><p>1、<strong>把握面试的沟通方向。</strong></p><p>如果陈述中谈到项目，面试官可能会问：</p><ul><li><p>负责了什么项目，项目是做什么的</p></li><li><p>和前端的结合点是？你的角色是？项目中承担了什么责任？</p></li><li><p>你在项目中的成绩？</p></li></ul><p>如果你说自己是项目<code>负责人</code>，会被问到：</p><ul><li><p>该项目怎么分配？有几个人参与？</p></li><li><p>作为负责人，你的角色是什么？是项目管理还是技术管理？</p></li><li><p>遇到技术难点，如何解决？</p></li></ul><h4 id="提问题"><a href="#提问题" class="headerlink" title="提问题"></a>提问题</h4><p>如果在深入问题时，碰到不会的，不要说“我不知道”。建议回答：</p><ul><li><p><strong>我要回去思考一下</strong>。</p></li><li><p>这方面我没有经验，能不能<strong>指点一下</strong>？</p></li><li><p>有什么建议或者参考资料吗？我想把这个东西弄懂。</p></li></ul><p>2、阔达、自信的适度发挥。</p><h2 id="css-相关知识点"><a href="#css-相关知识点" class="headerlink" title="css 相关知识点"></a>css 相关知识点</h2><h3 id="面试基础"><a href="#面试基础" class="headerlink" title="面试基础"></a>面试基础</h3><ul><li><p>页面布局</p></li><li><p>CSS盒模型：是CSS的基石。</p></li><li><p>DOM事件</p></li><li><p>HTTP协议</p></li><li><p>面向对象</p></li><li><p>原型链：能说出原型链的始末</p></li></ul><h3 id="面试进阶"><a href="#面试进阶" class="headerlink" title="面试进阶"></a>面试进阶</h3><ul><li><p>通信：普通的通信、跨域通信</p></li><li><p>安全：CSRF、XSS。</p></li><li><p>算法</p></li></ul><h3 id="回答问题时要注意的"><a href="#回答问题时要注意的" class="headerlink" title="回答问题时要注意的"></a>回答问题时要注意的</h3><p>（1）题干的要求真的是字面要求的这么简单吗？</p><p>（2）答案怎么写，技巧在哪里</p><p>（3）如果想证明我的实力，应该有几种答案？</p><p>本文来讲一下页面布局。</p><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p>问题：假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。</p><p>分析：</p><p>初学者想到的答案有两种：</p><ul><li><p>方法1：浮动</p></li><li><p>方法2：绝对定位。</p></li></ul><p>但要求你能至少写出三四种方法，才算及格。剩下的方法如下：</p><ul><li><p>方法3：flexbox。移动开发里经常用到。</p></li><li><p>方法4：表格布局 table。虽然已经淘汰了，但也应该了解。</p></li><li><p>方法5：网格布局 grid。</p></li></ul><p>下面分别讲解。</p><h3 id="方法1-和方法2"><a href="#方法1-和方法2" class="headerlink" title="方法1 和方法2"></a>方法1 和方法2</h3><p><strong>方法1、浮动：</strong></p><p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p><h3 id="方法2、绝对定位："><a href="#方法2、绝对定位：" class="headerlink" title="方法2、绝对定位："></a>方法2、绝对定位：</h3><p>左侧设置为绝对定位，  left：0px。右侧设置为绝对定位， right：0px。中间设置为绝对定位，left 和right 都为300px，即可。中间的宽度会自适应。</p><p>使用<code>article</code>标签作为容器，包裹左、中、右三个部分。</p><h3 id="方法3、flexbox布局"><a href="#方法3、flexbox布局" class="headerlink" title="方法3、flexbox布局"></a>方法3、flexbox布局</h3><p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p><h3 id="方法4、表格布局-table"><a href="#方法4、表格布局-table" class="headerlink" title="方法4、表格布局 table"></a>方法4、表格布局 table</h3><p>设置整个容器的宽度为100%，设置三个部分均为表格，然后左边的单元格为 300px，右边的单元格为 300px，即可。中间的单元格会自适应。</p><h3 id="方法5、网格布局-grid"><a href="#方法5、网格布局-grid" class="headerlink" title="方法5、网格布局 grid"></a>方法5、网格布局 grid</h3><h3 id="延伸：五种方法的对比"><a href="#延伸：五种方法的对比" class="headerlink" title="延伸：五种方法的对比"></a>延伸：五种方法的对比</h3><ul><li><p>五种方法的优缺点</p></li><li><p>考虑中间模块的高度问题</p></li><li><p>兼容性问题：实际开发中，哪个最实用？</p></li></ul><p>方法1：浮动：</p><ul><li><p>优点：兼容性好。</p></li><li><p>缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。</p></li></ul><p>方法:2：绝对定位</p><ul><li><p>优点：快捷。</p></li><li><p>缺点：导致子元素也脱离了标准文档流，可实用性差。</p></li></ul><p>方法3：flex 布局（CSS3中出现的）</p><ul><li>优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。</li></ul><p>方法4：表格布局</p><ul><li><p>优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局</p></li><li><p>缺点：因为三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。</p></li></ul><p>什么时候用 flex 布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。</p><p>方法5：网格布局</p><ul><li>CSS3中引入的布局，很好用。代码量简化了很多。</li></ul><p>PS：面试提到网格布局，说明我们对新技术是有追求的。</p><h3 id="延伸：如果题目中去掉高度已知"><a href="#延伸：如果题目中去掉高度已知" class="headerlink" title="延伸：如果题目中去掉高度已知"></a>延伸：如果题目中去掉高度已知</h3><p>问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？</p><p>分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。</p><p>答案是：<strong>flex 布局和表格布局可以通用</strong>，其他三个布局都不能用了。</p><h3 id="页面布局的变通"><a href="#页面布局的变通" class="headerlink" title="页面布局的变通"></a>页面布局的变通</h3><p><img src="http://img.smyhvae.com/20180305_1931.png"></p><p><code>上下高度固定，中间自适应</code>，这个在移动端的页面中很常见。</p><h3 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h3><p>（1）基本概念：content、padding、margin。</p><p>（2）标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人。</p><p>（3）CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</p><p>（4）JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</p><p>（5）实例题：根据盒模型解释<strong>边距重叠</strong>。</p><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p><p>（6）BFC（边距重叠解决方案）或IFC。</p><p><strong>标准盒模型和怪异盒模型</strong></p><p>在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：</p><ul><li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。</li></ul><p>CSS盒模型和IE盒模型的区别：</p><ul><li><p>在 <font color="#0000FF"><strong>标准盒子模型</strong></font>中，<font color="#0000FF"><strong>width 和 height 指的是内容区域</strong></font>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p></li><li><p><font color="#0000FF"><strong>IE盒子模型</strong></font>中，<font color="#0000FF"><strong>width 和 height 指的是内容区域+border+padding</strong></font>的宽度和高度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">    box-sizing: content-box;</span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure></li></ul><h2 id="margin塌陷-margin重叠"><a href="#margin塌陷-margin重叠" class="headerlink" title="margin塌陷/margin重叠"></a>margin塌陷/margin重叠</h2><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。</p><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有margin重叠的现象的。</p><p>我们来看几个例子。</p><h3 id="兄弟元素之间"><a href="#兄弟元素之间" class="headerlink" title="兄弟元素之间"></a>兄弟元素之间</h3><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png"></p><h3 id="子元素和父元素之间"><a href="#子元素和父元素之间" class="headerlink" title="子元素和父元素之间"></a>子元素和父元素之间</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。</p><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png"></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png"></p><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p><h3 id="善于使用父亲的padding，而不是儿子的margin"><a href="#善于使用父亲的padding，而不是儿子的margin" class="headerlink" title="善于使用父亲的padding，而不是儿子的margin"></a>善于使用父亲的padding，而不是儿子的margin</h3><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p><p><img src="http://img.smyhvae.com/20170806_1537.png"></p><p>此时我们给父亲div加一个border属性，就正常了：</p><p><img src="http://img.smyhvae.com/20170806_1544.png"></p><p>如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的margin。</p><h2 id="BFC（边距重叠解决方案）"><a href="#BFC（边距重叠解决方案）" class="headerlink" title="BFC（边距重叠解决方案）"></a>BFC（边距重叠解决方案）</h2><h3 id="BFC的概念"><a href="#BFC的概念" class="headerlink" title="BFC的概念"></a>BFC的概念</h3><p>BFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。</p><p>另外还有个概念叫IFC。不过，BFC问得更多。</p><h3 id="BFC-的原理-BFC的布局规则【非常重要】"><a href="#BFC-的原理-BFC的布局规则【非常重要】" class="headerlink" title="BFC 的原理/BFC的布局规则【非常重要】"></a>BFC 的原理/BFC的布局规则【非常重要】</h3><p>BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：</p><ul><li><p>（1）BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</p></li><li><p>（2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</p></li><li><p>（3）<strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</p></li><li><p>（4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</p></li></ul><h3 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h3><p>有以下几种方法：</p><ul><li><p>方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】</p></li><li><p>方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。</p></li><li><p>方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个BFC。</p></li><li><p>方法4：display为inline-block, table-cell, table-caption, flex, inline-flex</p></li></ul><p>参考链接：</p><ul><li><a href="https://segmentfault.com/a/1190000006740129">BFC原理详解</a></li></ul><ul><li><a href="https://www.jianshu.com/p/bf927bc1bed4">BFC详解</a></li></ul><ul><li><a href="https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">前端精选文摘：BFC 神奇背后的原理</a></li></ul><p>下面来看几个例子，看看如何生成BFC。</p><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><p><strong>举例1：</strong>解决 margin 重叠</p><p>当父元素和子元素发生 margin 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p><p>比如说，针对下面这样一个 div 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 150<span class="selector-tag">px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father-layout&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png"></p><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span> <span class="attr">style</span>=<span class="string">&quot;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.smyhvae.com/20180306_0827.png"></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png"></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0845.png"></p><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>涉及到的知识点：</p><p>（1）语义化掌握到位：每个区域用<code>section</code>、<code>article</code>代表容器、<code>div</code>代表块儿。如果通篇都用 div，那就是语义化没掌握好。</p><p>（2）页面布局理解深刻。</p><p>（3）CSS基础知识扎实。</p><p>（4）思维灵活且积极上进。题目中可以通过<code>网格布局</code>来体现。</p><p>（5）代码书写规范。注意命名。上面的代码中，没有一行代码是多的。</p><h2 id="js知识点"><a href="#js知识点" class="headerlink" title="js知识点"></a>js知识点</h2><h3 id="js-中的-数组的处理方法"><a href="#js-中的-数组的处理方法" class="headerlink" title="js 中的 数组的处理方法"></a>js 中的 数组的处理方法</h3><p>shift（）删除数组第一项</p><p>pop（）删除数组最后一项</p><p>slice（start，end）返回下标start 到end 之间的值 不包括end 包括start</p><p>splice（start，end）删除从start 到end之间的值 包括start 和 end</p><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>实现思路：新建一个数组，遍历要去重的数组  当值不在新数组的时候（indexof==-1）把它推到新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quchong</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> kong = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kong.indexOf(arr[i]==-<span class="number">1</span>))&#123;</span><br><span class="line">            kong.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Es6 实现 用set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> quchong = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [...quchong]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js-中-几种数据类型的转换"><a href="#js-中-几种数据类型的转换" class="headerlink" title="js 中 几种数据类型的转换"></a>js 中 几种数据类型的转换</h3><p>转化成字符串：</p><p> toString()方法 不可转换null undefined</p><p> Sting()方法都可以转换</p><p>隐式转换 num + “” 转换成字符串 进行拼接</p><p>转化成数字:</p><p>Number()方法</p><p>parseInt() 如果第一个字符是数字 解析到非数字结束</p><p>parseFloat() 解析第一个点 如果遇到第二个点 或者 非数字结束</p><p>隐式转换 num - 0 转化成数</p><p>转化成Boolean：</p><p>Boolean()   0 “”  null undefined  NaN 会转化成false 其他的转化成true</p><p>隐式转换  ！！a</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型：null   undefined  String  Number Boolean </p><p>引用数据类型：object(function  Date  arr)  symbol bigInt</p><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><p>typeof </p><h3 id="判断是否为数组"><a href="#判断是否为数组" class="headerlink" title="判断是否为数组"></a>判断是否为数组</h3><p>arr instanceof Arr</p><p>Array.isArray（arr）</p><p>arr.constructor === Array</p><h3 id="js中常见的一些错误……"><a href="#js中常见的一些错误……" class="headerlink" title="js中常见的一些错误……"></a>js中常见的一些错误……</h3><p>Cannot read property  当读取一个为定义的对象的属性 或者调用其方法时 </p><p>Cannot set property 访问一个未定义的变量时</p><p>undefined is not a function 调用未定义的函数时</p><h3 id="js中的循环"><a href="#js中的循环" class="headerlink" title="js中的循环"></a>js中的循环</h3><p><strong>filter()</strong></p><p>filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p><p><strong>map()</strong></p><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p><p>下面代码利用map方法实现数组中每个数求平方。</p><p><strong>forEach()</strong></p><p>forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p><p>join()<br>push()和pop()<br>shift() 和 unshift()<br>sort()<br>reverse()<br>concat()<br>slice()<br>splice()<br>indexOf()和 lastIndexOf() （ES5新增）<br>forEach() （ES5新增）<br>map() （ES5新增）<br>filter() （ES5新增）<br>every() （ES5新增）<br>some() （ES5新增）</p><h3 id="JS设置、获取盒模型对应的宽和高"><a href="#JS设置、获取盒模型对应的宽和高" class="headerlink" title="JS设置、获取盒模型对应的宽和高"></a>JS设置、获取盒模型对应的宽和高</h3><p><strong>1.通过DOM节点的 style 样式获取</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.style.width&#x2F;height;</span><br></pre></td></tr></table></figure><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p><p>这种方式有局限性，但应该了解。</p><p><strong>2.通用方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.getComputedStyle(element).width&#x2F;height;</span><br></pre></td></tr></table></figure><h3 id="方式三（IE独有的）"><a href="#方式三（IE独有的）" class="headerlink" title="方式三（IE独有的）"></a>方式三（IE独有的）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></table></figure><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p><h3 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></table></figure><p>此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。</p><p>此 api 可以拿到四个属性：left、top、width、height。</p><p><strong>总结：</strong></p><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="2020/12/25/da-jian-ge-ren-bo-ke/"/>
      <url>2020/12/25/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="github-搭建自己的博客"><a href="#github-搭建自己的博客" class="headerlink" title="github 搭建自己的博客"></a>github 搭建自己的博客</h2><p>参考详细网址   <a href="https://zhuanlan.zhihu.com/p/35668237">https://zhuanlan.zhihu.com/p/35668237</a></p><p><strong>注意事项：</strong>上面的title  date  tags 冒号后面一定要有空格 否则报错传不了</p><h2 id="码云搭建自己的博客"><a href="#码云搭建自己的博客" class="headerlink" title="码云搭建自己的博客"></a>码云搭建自己的博客</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建自己的博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
